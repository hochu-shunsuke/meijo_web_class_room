# -*- coding: utf-8 -*-
"""webclass課題取得.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1quzhlPPpRdZ-RLYrjoJy1s1uqOfr7SRU
"""



# 🟥1番目のコードセル🟥

# ----------------------------------------------------------------------
# 🌟 STEP 1: 初期設定 (ここだけ変更) 🌟
# ----------------------------------------------------------------------

# 1. 必要なライブラリをインストール
# !pip install requests beautifulsoup4

# 2. 🚨 GAS WebアプリのURLをここに貼り付けてください 🚨
#    (スプレッドシートの「✨ システム初期設定」メニューから取得したもの)
GAS_WEB_APP_URL = 'あなたのGAS WebアプリURLをここに貼り付けてください'

# 3. webclassのログイン情報をColabのSecretsに設定
# 左側メニューの，シークレットに以下の情報を追加してください
# - 「USER_ID」: あなたのWebClassのユーザーID
# - 「PASSWORD」: あなたのWebClassのパスワード


# 🟥2番目のコードセル（修正禁止）🟥

# ----------------------------------------------------------------------
# 🚀 STEP 2: 実行（このセル全体をクリック！） 🚀
# ----------------------------------------------------------------------

# ----------------------------------------------------------------------
# ⚙️ システムコアロジック（ここから下は変更しないでください）
# ----------------------------------------------------------------------
import re
import urllib.parse
import json
import requests
import time
import random
import os
from typing import Optional, Dict
from bs4 import BeautifulSoup

# --- WebClass Client 定数 ---
SSO_URL = 'https://slbsso.meijo-u.ac.jp/opensso/json/authenticate'
MAX_RETRIES = 5
RETRY_DELAY = 1
WEBCLASS_BASE_URL = 'https://rpwebcls.meijo-u.ac.jp'
USER_AGENTS = [
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/58.0.3029.110 Safari/537.36',
    'Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/15.1 Safari/605.1.15',
    'Mozilla/5.0 (X11; Linux x86_64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/91.0.4472.114 Safari/537.36',
    'Mozilla/5.0 (Windows NT 6.1; WOW64; rv:40.0) Gecko/20100101 Firefox/40.1',
    'Mozilla/5.0 (iPhone; CPU iPhone OS 14_0 like Mac OS X) AppleWebKit/605.1.15 (KHTML, like Gecko) Version/14.0 Mobile/15A372 Safari/604.1',
    'Mozilla/5.0 (Linux; Android 10; SM-G975F) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.106 Mobile Safari/537.36',
    'Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/117.0'
]

REDIRECT_REGEX = re.compile(r'window.location.href\s*=\s*"([^"]+)"')
ID_REGEX = re.compile(r'id=([a-f0-9]+)')

# --- WebClass Client/Parser ヘルパー関数 (定義は省略) ---
# ... (build_headers, _get_sso_token, _get_acs_path, WebClassClient, parse_course_contents の定義) ...

def build_headers(referer: Optional[str] = None) -> Dict[str, str]:
    ua = random.choice(USER_AGENTS)
    headers = {
        "User-Agent": ua, "Accept": "text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,*/*;q=0.9",
        "Accept-Language": "ja-JP,ja;q=0.9,en-US;q=0.8,en;q=0.7",
        "Accept-Encoding": "gzip, deflate, br", "Connection": "keep-alive",
    }
    if referer: headers["Referer"] = referer
    return headers

def _get_sso_token(userid, password):
    headers = {'Content-Type': 'application/json'}
    try:
        source_res = requests.post(SSO_URL, headers=headers)
        source_res.raise_for_status()
        jsn = source_res.json()
        jsn["callbacks"][0]["input"][0]["value"] = userid
        jsn["callbacks"][1]["input"][0]["value"] = password

        for atdatat in range(MAX_RETRIES):
            token_res = requests.post(SSO_URL, headers=headers, json=jsn)
            if token_res.status_code == 200:
                token_data = token_res.json()
                print(f"SSOトークン取得成功．")
                return token_data["tokenId"]
            print(f"認証試行 {atdatat + 1}/{MAX_RETRIES} 失敗 (Status: {token_res.status_code}). {RETRY_DELAY}秒後リトライ...")
            time.sleep(RETRY_DELAY)
        raise Exception(f"トークン取得失敗 (Status: {token_res.status_code})")
    except requests.exceptions.RequestException as e:
        print(f"SSOサーバーへの接続に失敗しました: {e}")
        raise
    except (KeyError, IndexError, json.JSONDecodeError) as e:
        print(f"SSOサーバーの応答形式が予期したものではありません: {e}")
        raise

def _get_acs_path(source):
    soup = BeautifulSoup(source, "html.parser")
    script_tag = soup.find("script")
    if script_tag and script_tag.string and '"' in script_tag.string:
        exccode = script_tag.string
        parts = exccode.split('"')
        if len(parts) > 1: return parts[1].replace('&amp;', "&")
    return None

class WebClassClient:
    def __init__(self, userid, password):
        print("認証セッションを開始します...")
        self.session = requests.Session()
        self.session.headers.update(build_headers())
        self.base_url = WEBCLASS_BASE_URL
        self.dashboard_url = None
        self._login(userid, password)

    def _login(self, userid, password):
        try:
            token_id = _get_sso_token(userid, password)
            login_url = f"{self.base_url}/webclass/login.php?auth_mode=SAML"
            res = self.session.get(login_url, allow_redirects=False)
            sso_location = res.headers["Location"]
            sso_cookies = {"iPlanetDirectoryPro": token_id}
            sso_res = self.session.get(sso_location, cookies=sso_cookies)
            sso_res.raise_for_status()
            soup = BeautifulSoup(sso_res.text, "html.parser")
            inputs = soup.find_all("input")
            data = {"SAMLResponse": inputs[0].attrs["value"], "RelayState": inputs[1].attrs["value"]}
            acs_url = f"{self.base_url}/simplesaml/module.php/saml/sp/saml2-acs.php/default-sp"
            self.session.post(acs_url, data=data, allow_redirects=False)
            login_php_res = self.session.get(login_url, allow_redirects=False)
            acs_path = _get_acs_path(login_php_res.text)
            if not acs_path: raise Exception("最終的なリダイレクトパス(acsPath)の取得に失敗しました．")
            self.dashboard_url = urllib.parse.urljoin(self.base_url, acs_path)
            self.session.get(self.dashboard_url).raise_for_status()
            print(f"ログイン成功！")
        except Exception as e:
            print(f"ログイン処理中にエラーが発生しました: {e}")
            raise

    def get(self, url, referer: Optional[str] = None, **kwargs):
        headers = build_headers(referer=referer)
        return self.session.get(url, headers=headers, **kwargs)

def parse_course_contents(html):
    soup = BeautifulSoup(html, 'html.parser')
    items = soup.find_all('section', class_='list-group-item cl-contentsList_listGroupItem')

    result = []
    for item in items:
        is_new = bool(item.find('div', class_='cl-contentsList_new'))
        title = ""; url = ""; share_link = ""

        if name_tag := item.find('h4', class_='cm-contentsList_contentName'):
            for new_tag in name_tag.find_all('div', class_='cl-contentsList_new'): new_tag.decompose()
            title = name_tag.get_text(strip=True)
            if a_tag := name_tag.find('a'):
                url = a_tag.get('href', '')
                if id_match := ID_REGEX.search(url):
                    share_link = f"{WEBCLASS_BASE_URL}/webclass/login.php?id={id_match.group(1)}&page=1&auth_mode=SAML"

        category = ""
        if category_tag := item.find('div', class_='cl-contentsList_categoryLabel'): category = category_tag.get_text(strip=True)

        period = ""
        for detail_item in item.find_all('div', class_='cm-contentsList_contentDetailListItem'):
            if label := detail_item.find('div', class_='cm-contentsList_contentDetailListItemLabel'):
                if "利用可能期間" in label.get_text():
                    if data := detail_item.find('div', class_='cm-contentsList_contentDetailListItemData'): period = data.get_text(strip=True)
                    break

        result.append({
            'title': title, 'url': url, 'share_link': share_link, 'is_new': is_new,
            'category': category, 'period': period
        })
    return result

# --- main.py 関数 ---

def get_course_links(client: WebClassClient):
    print("ダッシュボードから科目リンクを取得中...")
    try:
        top_html = client.get(client.dashboard_url).text
        soup = BeautifulSoup(top_html, "html.parser")
        course_links = set()
        for a_tag in soup.find_all('a', href=True, class_='list-group-item course'):
            raw_name = a_tag.get_text(strip=True)
            name = re.sub(r'^»?\s*\d+\s*', '', raw_name)
            href = a_tag.get("href")
            if href and '/webclass/course.php/' in href: course_links.add((name, href))
        print(f"科目リンク抽出数: {len(course_links)}")
        if not course_links: print("警告: 科目が見つかりません．")
        return list(course_links)
    except Exception as e:
        print(f"科目リンクの取得に失敗しました: {e}")
        return []

def fetch_and_parse_course(course_info, client: WebClassClient):
    course_name, href = course_info
    session = client.session
    base_url = client.base_url

    try:
        url = urllib.parse.urljoin(base_url, href)
        res = session.get(url)
        html = res.text

        soup = BeautifulSoup(html, "html.parser")
        script = soup.find("script")
        if script and script.string and "window.location.href" in script.string:
            m = REDIRECT_REGEX.search(script.string)
            if m:
                redirect_url = urllib.parse.urljoin(base_url, m.group(1))
                res = session.get(redirect_url)
                html = res.text

        data = parse_course_contents(html)
        return course_name, data, "成功"
    except Exception as e:
        return course_name, None, f"失敗: {e}"

def send_data_to_gas(assignments):
    global GAS_WEB_APP_URL
    if not GAS_WEB_APP_URL or 'YOUR_PASTED_GAS_WEB_APP_URL_HERE' in GAS_WEB_APP_URL:
        print("🚨 GAS WebアプリURLが未設定のため、データ送信をスキップしました。")
        return

    try:
        headers = {'Content-Type': 'application/json'}
        payload = json.dumps({'assignments': assignments})

        print(f"GAS Webアプリにデータを送信中...")

        response = requests.post(GAS_WEB_APP_URL, headers=headers, data=payload)
        response.raise_for_status()

        gas_response = response.json()

        if gas_response.get('status') == 'SUCCESS':
            print("✅ GASへのデータ送信と書き込みに成功しました。")
        else:
            print(f"🚨 GAS側でエラーが発生しました: {gas_response.get('message', '不明なエラー')}")

    except requests.exceptions.RequestException as e:
        print(f"🚨 GASへのHTTP通信中にエラーが発生しました: {e}")
    except json.JSONDecodeError:
        print(f"🚨 GASからの応答が不正です: {response.text}")

def main():
    # 1. Colab Secretsから資格情報取得
    try:
        from google.colab import userdata

        WEBCLASS_USERID = userdata.get('WEBCLASS_USERID')
        WEBCLASS_PASSWORD = userdata.get('WEBCLASS_PASSWORD')

        if not WEBCLASS_USERID or not WEBCLASS_PASSWORD:
            print("🚨 Colab Secretsに認証情報が設定されていません。")
            return

        userdata_dict = {"userid": WEBCLASS_USERID, "password": WEBCLASS_PASSWORD}
        print("WebClass認証情報をColab Secretsから取得しました。")
    except ImportError:
        print("🚨 Colab環境外で実行されています。このノートブックはColab専用です。")
        return
    except Exception as e:
        print(f"認証情報の取得に失敗しました: {e}")
        return

    # 2. WebClassログイン
    try:
        client = WebClassClient(userdata_dict["userid"], userdata_dict["password"])
    except Exception as e:
        print(f"ログインに失敗しました: {e}")
        return

    # 3. 科目一覧を取得
    course_links = get_course_links(client)
    if not course_links:
        print("処理する科目がありません．終了します．")
        return

    # 4. 全科目を処理し、課題データを収集
    all_assignments = []
    print(f"{len(course_links)}件の科目を処理します...")

    for i, course in enumerate(course_links):
        course_name, parsed_data, result = fetch_and_parse_course(course, client)
        print(f"  ({i+1}/{len(course_links)}) [{result}] - {course_name}")

        if result == "成功" and parsed_data:
            for item in parsed_data:
                period_str = item.get('period', '')
                due_date_str = ''
                if ' - ' in period_str:
                    due_date_str = period_str.split(' - ')[1].strip()
                else:
                    due_date_str = period_str

                # GASの列構成に合わせてデータを整形
                # [0:ソース, 1:授業名, 2:課題タイトル, 3:締切日時, 4:課題リンク (URL), 5:Tasks ID, 6:登録済みフラグ]
                row = [
                    'WebClass',
                    course_name,
                    item['title'] + f" ({item['category']})",
                    due_date_str,
                    item['share_link'],
                    '',
                    ''
                ]
                all_assignments.append(row)

    if not all_assignments:
        print("WebClassからコンテンツは見つかりませんでした．")
        return

    # 5. GAS Webアプリにデータを送信
    send_data_to_gas(all_assignments)

    print("すべての処理が完了しました．")

# --- メイン関数の呼び出し ---
if __name__ == "__main__":
    main()