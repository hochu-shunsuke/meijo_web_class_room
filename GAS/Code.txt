// Code.gs

// ====================================================================
//  GAS 課題リマインドシステム - 最終完全版 (WebClass内部取得 & Tasks統合)
//  Config.gs のすべての定数を利用します。
// ====================================================================

// --- メインフロー実行関数 ---

/**
 * 【メイン関数】毎日定刻に実行するトリガーに設定します。
 */
function dailySystemRun() {
  Logger.log('--- 課題リマインドシステム 実行開始 ---');
  const ui = SpreadsheetApp.getUi();
  
  try {
    logToSheet('--- 課題リマインドシステム 実行開始 ---');
    
    // 1. WebClassの最新データを取得し、シートに書き込む (WebClass認証が必要)
    fetchWebClassAssignments();
    
    // 2. Classroomの最新データを取得し、シートに書き込む
    fetchClassroomAssignments(); 
    
    // Tasks連携が設定されている場合のみ実行
    if (getTaskListIdProperty()) {
      // 3. Tasksの完了状態をスプレッドシートに反映させる（同期）
      syncTaskCompletionStatus(); 
      
      // 4. スプレッドシートの統合データから、未登録・期限内の課題をTasksに追加
      integrateAndRegisterTasks();
    } else {
      logToSheet('⚠️ TasksリストIDが未設定のため、同期・登録処理をスキップしました。');
    }
    
    // 5. 古いデータや完了済みのデータをシートから削除（整理）
    cleanupOldAssignments(); 
    
    Logger.log('--- 課題リマインドシステム 実行完了 ---');
    ui.alert('✅ 全ての課題取得と同期処理が完了しました！');
    
  } catch(e) {
    Logger.log(`致命的なシステムエラー: ${e.toString()}`);
    // 意図的な診断中断エラーの場合もアラートを表示
    if (e.message.includes('WebClass課題抽出診断のため') || e.message.includes('WebClassダッシュボードアクセス失敗')) {
        ui.alert(`🚨 診断中断: ${e.message}`);
    } else if (e.message.includes('SSOトークン取得に失敗しました')) {
      // ログインエラーの場合は、ここでは追加アラートを出さない
    } else {
      ui.alert(`🚨 致命的なシステムエラーが発生しました。\nLoggerをご確認ください。\n${e.message}`);
    }
  }
}

// --- WebClass 課題取得関数 ---

/**
 * WebClassから全科目の課題を取得し、シートに書き込む
 */
function fetchWebClassAssignments() {
  Logger.log('1. WebClassの課題取得処理を開始...');
  logToSheet('--- WebClass 課題取得処理 開始 ---');
  
  const credentials = getCredentials(); 
  if (!credentials) {
    throw new Error('WebClassの認証情報が設定されていません。「1. 認証情報を設定」から設定してください。');
  }
  
  const dashboardUrl = loginWebClass(credentials.userid, credentials.password);
  const dashboardHtml = fetchWithSession(dashboardUrl);
  const courseLinks = parseDashboardForCourseLinks(dashboardHtml); 
  
  if (courseLinks.length === 0) {
    throw new Error('WebClass課題抽出診断のため、メインフローを停止しました。科目リンクが見つかりませんでした。');
  }
  
  Logger.log(`✅ WebClassから${courseLinks.length}件の科目リンクを正常に取得しました。個別コースの課題取得を開始します。`);
  logToSheet(`✅ ${courseLinks.length}件の科目リンクを抽出しました。`);
  
  const allAssignmentRows = [];
  let totalAssignments = 0;
  
  // 4. 各コースページにアクセスして課題情報を収集
  courseLinks.forEach((course, index) => {
    const courseLogMessage = `[${index + 1}/${courseLinks.length}] 科目: ${course.name} | URL: ${course.url} を取得中...`;
    Logger.log(courseLogMessage);
    logToSheet(courseLogMessage); 
    
    try {
      const courseHtml = fetchWithSession(course.url);
      
      const htmlSize = courseHtml.length;
      const contentSnippet = courseHtml.substring(0, 200).replace(/\s+/g, ' '); 
      
      const successMessage = `   -> HTML取得成功。サイズ: ${htmlSize} バイト。コンテンツ先頭: ${contentSnippet}...`;
      Logger.log(successMessage);
      logToSheet(successMessage); 

      // 4-2. 課題情報を解析 (Parser.gsに依存)
      const assignments = parseCourseContents(courseHtml); 
      
      Logger.log(`   -> 課題を${assignments.length}件検出しました。`);
      logToSheet(`   -> 課題を${assignments.length}件検出しました。解析結果を行に追加します。`);
      
      // 4-3. データを行形式に変換
      assignments.forEach(assignment => {
        const startPeriodStr = assignment.start_period || ''; // 新しい開始日時
        const endPeriodStr = assignment.end_period || '';     // 新しい終了日時
        
        // 【要求されたロギング】課題の詳細情報をログに出力
        const assignmentLog = `      - 課題検出: T[${assignment.title}] P[${startPeriodStr} - ${endPeriodStr}] C[${assignment.category}] L[${assignment.share_link.substring(0, 50)}...]`;
        Logger.log(assignmentLog);
        logToSheet(assignmentLog);
        
        // ★データ構造を8列（開始日時、終了日時を含む）に変更
        allAssignmentRows.push([
          'WebClass',                   // ソース (0)
          course.name,                  // 授業名 (1)
          assignment.title,             // 課題タイトル (2)
          startPeriodStr,               // 開始日時 (3) - NEW
          endPeriodStr,                 // 終了日時 (4) - NEW
          assignment.share_link,        // 課題リンク (URL) (5)
          '',                           // Tasks ID (6)
          ''                            // 登録済みフラグ (7)
        ]);
        totalAssignments++;
      });
      
    } catch (e) {
      Logger.log(`🚨 科目「${course.name}」の課題取得中にエラーが発生しました: ${e.message}。この科目をスキップします。`);
      logToSheet(`🚨 科目「${course.name}」の課題取得中にエラーが発生しました: ${e.message}。`);
    }
    
    Utilities.sleep(300); 
  });
  
  Logger.log(`💡 全てのコースから合計${totalAssignments}件の課題を収集しました。`);
  logToSheet(`💡 全てのコースから合計${totalAssignments}件の課題を収集しました。`);
  
  // 5. スプレッドシートへの書き込み
  writeWebClassAssignmentsToSheet(allAssignmentRows);
  
  Logger.log('✅ WebClass課題取得処理 完了。');
  logToSheet('--- WebClass 課題取得処理 完了 ---');
}

// --- Classroom 課題取得関数 (新規追加) ---

/**
 * Classroomの最新データを取得し、シートに書き込む
 */
function fetchClassroomAssignments() {
  Logger.log('2. Classroomの課題取得処理を開始...');
  logToSheet('--- Classroom 課題取得処理 開始 ---');
  
  try {
    const courses = Classroom.Courses.list({
        courseStates: ['ACTIVE'] 
    }).courses;

    if (!courses || courses.length === 0) {
      Logger.log('🚨 Classroomにアクティブなコースが見つかりませんでした。');
      logToSheet('🚨 Classroomにアクティブなコースが見つかりませんでした。');
      return;
    }
    
    Logger.log(`✅ Classroomから${courses.length}件のコースを検出しました。`);
    
    const allAssignmentRows = [];
    let totalAssignments = 0;
    
    courses.forEach(course => {
      const courseWorks = Classroom.Courses.CourseWork.list(course.id, {
          courseWorkStates: ['PUBLISHED']
      }).courseWork;

      if (!courseWorks) return;
      
      courseWorks.forEach(work => {
        // 締切(dueDate)情報がない課題はスキップ
        if (!work.dueDate && !work.dueTime) return; 

        let dueDateString = '';
        if (work.dueDate) {
          const { year, month, day } = work.dueDate;
          const date = new Date(year, month - 1, day); 
          
          if (work.dueTime) {
            const { hours, minutes } = work.dueTime;
            date.setHours(hours || 0, minutes || 0);
          }
          
          dueDateString = Utilities.formatDate(date, Session.getScriptTimeZone(), 'yyyy/MM/dd HH:mm'); // 書式をWebClassに合わせる
        }

        const assignmentLink = work.alternateLink;

        // 【ロギング】課題の詳細情報をログに出力
        const assignmentLog = `      - Classroom課題検出: T[${work.title}] D[${dueDateString}] L[${assignmentLink.substring(0, 50)}...]`;
        Logger.log(assignmentLog);
        logToSheet(assignmentLog);
        
        // ★データ構造を8列に変更。Classroomの締切は「終了日時」に格納し、「開始日時」は空欄
        allAssignmentRows.push([
          'Classroom',                  // ソース (0)
          course.name,                  // 授業名 (1)
          work.title,                   // 課題タイトル (2)
          '',                           // 開始日時 (3) - 空欄
          dueDateString,                // 終了日時 (4) - 締切日時
          assignmentLink,               // 課題リンク (URL) (5)
          '',                           // Tasks ID (6)
          ''                            // 登録済みフラグ (7)
        ]);
        totalAssignments++;
      });
      Utilities.sleep(100); 
    });
    
    Logger.log(`💡 全てのClassroomコースから合計${totalAssignments}件の課題を収集しました。`);
    logToSheet(`💡 全てのClassroomコースから合計${totalAssignments}件の課題を収集しました。`);
    
    // 3. スプレッドシートへの書き込み
    writeClassroomAssignmentsToSheet(allAssignmentRows);
    
  } catch (e) {
    Logger.log(`🚨 Classroom課題取得中に致命的なエラーが発生しました: ${e.message}`);
    logToSheet(`🚨 Classroom課題取得中に致命的なエラーが発生しました: ${e.message}。Classroom APIが有効化されているか確認してください。`);
  }
  
  Logger.log('✅ Classroom課題取得処理 完了。');
  logToSheet('--- Classroom 課題取得処理 完了 ---');
}


// --- プレースホルダ関数群 ---

// Tasksの完了状態をスプレッドシートに反映させる（同期）
function syncTaskCompletionStatus() {
  Logger.log('3. Tasks完了状態の同期は未実装です。');
  logToSheet('3. Tasks完了状態の同期は未実装です。');
}

// スプレッドシートの統合データから、未登録・期限内の課題をTasksに追加
function integrateAndRegisterTasks() {
  Logger.log('4. Tasksへの課題登録は未実装です。');
  logToSheet('4. Tasksへの課題登録は未実装です。');
}

// 古いデータや完了済みのデータをシートから削除（整理）
function cleanupOldAssignments() {
  Logger.log('5. 古いデータの整理は未実装です。');
  logToSheet('5. 古いデータの整理は未実装です。');
}


// --- ヘルパー関数群 ---

/**
 * 取得したWebClassの課題データをスプレッドシートに書き込む
 */
function writeWebClassAssignmentsToSheet(dataRows) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // SHEET_NAME_WEBCLASS, HEADERはConfig.gsで定義されているものとする
  const sheet = ss.getSheetByName(SHEET_NAME_WEBCLASS) || ss.insertSheet(SHEET_NAME_WEBCLASS);
  
  // 既存データのクリア (ヘッダー行を除く全コンテンツをクリア)
  if (sheet.getLastRow() > 1) {
    sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
  }
  
  // ヘッダー書き込み (A1から)
  sheet.getRange(1, 1, 1, HEADER.length).setValues([HEADER]).setFontWeight('bold');
  
  // データ書き込み
  if (dataRows.length > 0) {
    sheet.getRange(2, 1, dataRows.length, dataRows[0].length).setValues(dataRows);
  }
  
  SpreadsheetApp.flush(); 
  logToSheet(`✅ ${dataRows.length}件のWebClass課題をシート「${SHEET_NAME_WEBCLASS}」に書き込みました。`);
}

/**
 * 取得したClassroomの課題データをスプレッドシートに書き込む
 */
function writeClassroomAssignmentsToSheet(dataRows) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  
  // SHEET_NAME_CLASSROOM, HEADERはConfig.gsで定義されているものとする
  const sheet = ss.getSheetByName(SHEET_NAME_CLASSROOM) || ss.insertSheet(SHEET_NAME_CLASSROOM);
  
  // 既存データのクリア (ヘッダー行を除く全コンテンツをクリア)
  if (sheet.getLastRow() > 1) {
    sheet.getRange(2, 1, sheet.getLastRow() - 1, sheet.getLastColumn()).clearContent();
  }
  
  // ヘッダー書き込み (A1から)
  sheet.getRange(1, 1, 1, HEADER.length).setValues([HEADER]).setFontWeight('bold');
  
  // データ書き込み
  if (dataRows.length > 0) {
    sheet.getRange(2, 1, dataRows.length, dataRows[0].length).setValues(dataRows);
  }
  
  SpreadsheetApp.flush(); 
  logToSheet(`✅ ${dataRows.length}件のClassroom課題をシート「${SHEET_NAME_CLASSROOM}」に書き込みました。`);
}

/**
 * 指定された名前のタスクリストのIDを取得する。存在しない場合は作成する。
 * @param {string} listName - タスクリスト名 (例: '大学課題')
 * @returns {string} タスクリストID
 */
function getTaskListId(listName) {
  const lists = Tasks.Tasklists.list().items;
  let taskListId = null;

  // 既存リストの検索
  for (const list of lists) {
    if (list.title === listName) {
      taskListId = list.id;
      break;
    }
  }

  // 存在しない場合は新規作成
  if (!taskListId) {
    const newTasklist = Tasks.Tasklists.insert({ title: listName });
    taskListId = newTasklist.id;
    Logger.log(`新規タスクリスト「${listName}」を作成しました。ID: ${taskListId}`);
  }

  return taskListId;
}

/**
 * 受信した課題データをシートに書き込む（Tasks IDとフラグを保持しながらマージする）
 * 【重要】8列構造（Tasks ID: 6, 登録済みフラグ: 7, リンク: 5）に対応
 */
function writeMergedAssignmentsToSheet(sheet, newAssignments) {
    // 1. 初期設定としてヘッダーを書き込む
    if (sheet.getLastRow() === 0) {
        sheet.getRange(1, 1, 1, HEADER.length).setValues([HEADER]).setFontWeight('bold');
    }
  
    // 2. 既存データを読み込み、リンクをキーとするマップを作成
    const existingDataMap = new Map();
    // Key: 課題リンク(URL), Value: [Tasks ID, 登録済みフラグ]
    const existingData = sheet.getLastRow() > 1 
        ? sheet.getRange(2, 1, sheet.getLastRow() - 1, HEADER.length).getValues()
        : [];
    
    // 既存のTasks IDと登録済みフラグを保持
    existingData.forEach(row => {
        const link = row[5]; // 課題リンク (URL) (Index 5)
        const tasksId = row[6]; // Tasks ID (Index 6)
        const registeredFlag = row[7]; // 登録済みフラグ (Index 7)
        if (link) {
            existingDataMap.set(link, [tasksId, registeredFlag]);
        }
    });
    
    const mergedAssignments = [];
  
    // 3. 新しい課題データに既存のTasks情報をマージ
    newAssignments.forEach(newRow => {
        const link = newRow[5]; // 課題リンク (URL) (Index 5)
        if (existingDataMap.has(link)) {
            const [tasksId, registeredFlag] = existingDataMap.get(link);
            newRow[6] = tasksId; // Tasks ID (Index 6)
            newRow[7] = registeredFlag; // 登録済みフラグ (Index 7)
        } else {
            newRow[6] = '';
            newRow[7] = '';
        }
        mergedAssignments.push(newRow);
    });

    // 4. 既存のデータ行をクリア（ヘッダー行は残す）
    sheet.getRange(2, 1, sheet.getMaxRows(), HEADER.length).clearContent();
    
    // 5. 結合したデータを2行目から書き込む
    if (mergedAssignments.length > 0) {
        sheet.getRange(2, 1, mergedAssignments.length, mergedAssignments[0].length).setValues(mergedAssignments);
    }
    
    // 6. 最終更新日時をA1に記載
    sheet.getRange('A1').setValue('最終更新: ' + new Date().toLocaleString());
    SpreadsheetApp.flush();
}

/**
 * Tasksの完了状態をスプレッドシートに反映させる（同期）
 * 【重要】8列構造（Tasks ID: 6, 登録済みフラグ: 7）に対応
 */
function syncTaskCompletionStatus() {
  logToSheet('--- Tasks完了状態の同期処理 開始 ---');
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetNames = [SHEET_NAME_WEBCLASS, SHEET_NAME_CLASSROOM]; 
  const taskListId = getTaskListIdProperty(); // Properties.gs の関数
  
  if (!taskListId) return;

  sheetNames.forEach(sheetName => {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() <= 1) return;
    
    const range = sheet.getRange(2, 1, sheet.getLastRow() - 1, HEADER.length);
    const data = range.getValues();
    let updated = false;

    data.forEach((row, index) => {
      const tasksId = row[6]; // Tasks ID (Index 6)
      const registeredFlag = row[7]; // 登録済みフラグ (Index 7)
      
      // Tasks IDがあり、かつまだ完了/削除済みとしてマークされていない場合のみチェック
      if (tasksId && registeredFlag !== 'COMPLETED' && registeredFlag !== 'DELETED') {
        try {
          const task = Tasks.Tasks.get(taskListId, tasksId);
          
          if (task.status === 'completed') {
            data[index][7] = 'COMPLETED'; // 完了
            updated = true;
            logToSheet(`✅ Tasks完了をシートに同期: ${row[2]} (${sheetName})`);
          }
        } catch (e) {
          // Tasks側でタスクが見つからない場合（ユーザーがTasks側で削除した場合など）
          if (e.toString().includes('notFound')) {
            data[index][7] = 'DELETED'; // 削除済み
            updated = true;
            logToSheet(`⚠️ Tasksでタスクが削除されていたためDELETEDにマーク: ${row[2]} (${sheetName})`);
          } else {
            Logger.log(`🚨 Tasks同期エラー (${tasksId}): ${e.message}`);
          }
        }
      }
    });

    if (updated) {
      range.setValues(data);
      SpreadsheetApp.flush();
      Logger.log(`${sheetName} のTasks完了状態を同期しました。`);
    }
  });
  logToSheet('--- Tasks完了状態の同期処理 完了 ---');
}


/**
 * スプレッドシートの統合データから、未登録・期限内の課題をTasksに追加
 * 【重要】8列構造（Tasks ID: 6, 登録済みフラグ: 7）に対応
 */
function integrateAndRegisterTasks() {
  const taskListId = getTaskListIdProperty(); 
  if (!taskListId) return;

  logToSheet('--- Tasks課題登録処理 開始 ---');

  const ss = SpreadsheetApp.getActiveSpreadsheet();
  const sheetNames = [SHEET_NAME_WEBCLASS, SHEET_NAME_CLASSROOM]; 

  sheetNames.forEach(sheetName => {
    const sheet = ss.getSheetByName(sheetName);
    if (!sheet || sheet.getLastRow() <= 1) return;

    const range = sheet.getRange(2, 1, sheet.getLastRow() - 1, HEADER.length);
    const data = range.getValues();
    let updated = false;

    data.forEach((row, index) => {
      const [source, courseName, title, startDate, dueDate, link, tasksId, registeredFlag] = row;
      
      // 未登録かつ未完了/削除済みフラグの課題を対象とする
      if (!tasksId && registeredFlag !== 'COMPLETED' && registeredFlag !== 'DELETED' && registeredFlag !== 'EXPIRED') {
        
        let dueDateTime = null;
        
        // ★修正点1: dueDateが有効な文字列であることを確認
        if (typeof dueDate === 'string' && dueDate.trim().length > 0) {
            
            // 期限が過去のものかチェック (dueDateが空欄でないこと)
            // 'yyyy/MM/dd HH:mm' 形式を Dateオブジェクトに変換
            const dateStr = dueDate.replace(/\//g, '-');
            dueDateTime = new Date(dateStr);
            
            if (dueDateTime.toString() === 'Invalid Date') {
                Logger.log(`🚨 無効な日付形式を検出 (${sheetName}, ${title}): ${dueDate}`);
                return; // 無効な日付はスキップ
            }
            
            if (dueDateTime.getTime() < new Date().getTime()) {
                // 既に期限切れの場合は登録しない
                row[7] = 'EXPIRED'; // 期限切れフラグをセット
                updated = true;
                return;
            }
        }

        try {
          // Tasks APIに登録するタスクオブジェクトを作成
          const task = Tasks.newTask();
          
          // 課題タイトルと授業名
          task.title = `[${courseName}] ${title}`;
          
          // 締切日時 (dueDateTimeが存在する場合のみ設定)
          if (dueDateTime) {
            // UTCに変換して、Tasksのdueに設定
            task.due = dueDateTime.toISOString().split('.')[0] + '.000Z';
          }
          
          // リンク (Notesとして追加)
          // dueDateは文字列として直接使用
          task.notes = `課題リンク:\n${link}\n\nソース: ${source}${startDate ? `\n開始日時: ${startDate}` : ''}${dueDate ? `\n終了日時/締切: ${dueDate}` : ''}`;

          // Tasks APIでタスクを挿入 (登録)
          const insertedTask = Tasks.Tasks.insert(task, taskListId);
          
          // スプレッドシートの該当行を更新
          data[index][6] = insertedTask.id; // Tasks IDをIndex 6に保存
          data[index][7] = 'REGISTERED';   // 登録済みフラグをIndex 7に設定
          updated = true;
          logToSheet(`✅ 課題をTasksに登録: ${task.title}`);
          
        } catch (e) {
          Logger.log(`🚨 Tasks登録失敗 (${sheetName}, ${title}): ${e.message}`);
          logToSheet(`🚨 Tasks登録失敗 (${title}): ${e.message}`);
        }
      }
    });

    if (updated) {
      range.setValues(data);
      SpreadsheetApp.flush();
    }
  });
  logToSheet('--- Tasks課題登録処理 完了 ---');
}


// --------------------------------------------------------------------
// --- 5. 古いデータや完了済みのデータをシートから削除（整理） ---
// --------------------------------------------------------------------

/**
 * 古いデータや完了済みのデータをシートから削除（整理）
 * 【重要】8列構造（Tasks ID: 6, 登録済みフラグ: 7）に対応
 */
function cleanupOldAssignments() {
    logToSheet('--- 古いデータ整理処理 開始 ---');
    const ss = SpreadsheetApp.getActiveSpreadsheet();
    const sheetNames = [SHEET_NAME_WEBCLASS, SHEET_NAME_CLASSROOM]; 
    const today = new Date();

    sheetNames.forEach(sheetName => {
        const sheet = ss.getSheetByName(sheetName);
        if (!sheet || sheet.getLastRow() <= 1) return;

        const dataRange = sheet.getRange(2, 1, sheet.getLastRow() - 1, HEADER.length);
        const data = dataRange.getValues();
        
        // 削除対象行のインデックスを格納
        const rowsToDelete = []; 

        data.forEach((row, index) => {
            const [source, courseName, title, startDate, dueDate, link, tasksId, registeredFlag] = row;
            
            // 1. Tasks連携済みで完了/削除済み/期限切れの課題
            if (['COMPLETED', 'DELETED', 'EXPIRED'].includes(registeredFlag)) {
                rowsToDelete.push(index + 2); // スプレッドシートの行番号はインデックス+2 
                return;
            }
            
            // 2. Tasks未連携の課題で、締切（終了日時）から一定期間（例: 7日）が経過したもの
            if (!tasksId && dueDate) {
                const dueDateTime = new Date(dueDate.replace(/\//g, '-'));
                // 締切から7日経過しているか
                const daysAfterDue = (today.getTime() - dueDateTime.getTime()) / (1000 * 60 * 60 * 24);
                
                if (daysAfterDue > 7) {
                    rowsToDelete.push(index + 2);
                }
            }
        });

        // 行番号が大きい順に削除することで、インデックスのずれを防ぐ
        rowsToDelete.sort((a, b) => b - a);

        rowsToDelete.forEach(rowNum => {
            sheet.deleteRow(rowNum);
        });
        
        if (rowsToDelete.length > 0) {
            Logger.log(`${sheetName} から ${rowsToDelete.length} 件の古いデータを削除しました。`);
            logToSheet(`✅ ${sheetName} から ${rowsToDelete.length} 件の古いデータを削除しました。`);
        }
    });
    logToSheet('--- 古いデータ整理処理 完了 ---');
}


/**
 * ログシートにタイムスタンプ付きでメッセージを記録する
 */
function logToSheet(message) {
  const ss = SpreadsheetApp.getActiveSpreadsheet();
  let logSheet = ss.getSheetByName('ログ');
  if (!logSheet) {
    logSheet = ss.insertSheet('ログ');
    logSheet.appendRow(['タイムスタンプ', 'メッセージ']);
  }
  
  logSheet.appendRow([new Date(), message]);
}